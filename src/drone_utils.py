# drone_utils.py
# drone utilities to support drone features

# Tue Oct  6 22:28:12 EDT 2020
# Designed with ❤️ by Simon Chu

import abc
import parser
from map_utils import Coord


class Shared_Flight_Data():
    """store collections of shared drone data during drone executions

    It is similar to Signal class, because it is allowed to store objects other than numeric values

    Attribute:
        flight_data_list: stores a dictionary of drone data indexed using the drone identifier

    Sample Shared Flight Data
    {"Ego": Drone_Flight_Data(), "Enemy": Drone_Flight_Data(), "ATC": ATC_Flight_Data()}
    """

    def __init__(self):
        self.flight_data_dict = dict()

    def count(self):
        """get the number of drones in the shared flight data"""
        return len(self.flight_data_dict)

    def add(self, flight_data):
        """add new entry to the drone_data_dict"""
        self.flight_data_dict[flight_data.get_id()] = flight_data

    def get(self, id):
        """get the flight data by the identifier of the drone"""
        if id in self.flight_data_dict.keys():
            return self.flight_data_dict[id]
        else:
            raise RuntimeError("id = " + str(id) +
                               " does not exist in the shared flight data.")
    def __str__(self):
        str_builder = "Shared Flight Data: \n"

        for key in self.flight_data_dict.keys():
            str_builder += str(self.flight_data_dict[key]) + "\n"

        return str_builder

class Flight_Data(metaclass=abc.ABCMeta):
    """store shared drone data during drone executions, contains critical drone parameters to understand the status of the drone,
    and communicate status between drones.

    It is similar to Signal Element class, because it is allowed to store objects other than numeric values

    Attribute:
        id: identifier of the flight data, it is either the identifier associated with the drone
            or the identifier associated with the air traffic control
        data: A dictionary that contains essential flight data of the drone

    Flight_Data can be either Drone_Flight_Data or ATC_Flight_Data
    """

    def __init__(self, id, data_dict=dict()):
        self.id = id
        self.data_dict = data_dict

    def get_id(self):
        return self.id

    # def add_data()
    def get_data(self):
        return self.data_dict

    def get_data_by_key(self, key):
        if key in self.data_dict.keys():
            return self.data_dict[key]
        else:
            raise RuntimeError(
                "key = " + str(key) + " does not exist in the flight data for drone = " + str(self.id))

    def __str__(self):
        return "id = " + str(self.id) + ", data = " + str(self.data_dict)

class Drone_Flight_Data(Flight_Data):
    """flight data for the drone, inherit Flight_Data class

    Attributes
        data_dict: a dictionary containing essential flight data, i.e. {"map_cell": ...}
        id: a string containing the identifier of the drone, i.e. "Ego"
    """

    def get_map_cell(self):
        """get the current step for the execution"""
        key = "map_cell"
        if key in self.data_dict.keys():
            return self.data_dict[key]
        else:
            raise RuntimeError(
                "key = " + str(key) + " does not exist in the flight data for drone = " + str(self.id))

    def get_coord(self):
        """get the current step for the execution"""
        key = "map_cell"
        if key in (self.data_dict).keys():
            return (self.data_dict[key]).get_coord()
        else:
            raise RuntimeError(
                "key = " + str(key) + " does not exist in the flight data for drone = " + str(self.id))


class ATC_Flight_Data(Flight_Data):
    """flight data for air traffic control, inherit Flight_Data class

    Sample ATC Flight Data

    {"step": ...}
    """

    def get_step(self):
        """get the current step for the execution"""
        key = "step"
        if key in self.data_dict.keys():
            return self.data_dict[key]
        else:
            raise RuntimeError(
                "key = " + str(key) + " does not exist in the flight data for ATC = " + str(self.id))

    def get_message(self):
        """get the message broadcasted for the execution"""
        key = "message"
        if key in self.data_dict.keys():
            return self.data_dict[key]
        else:
            raise RuntimeError(
                "key = " + str(key) + " does not exist in the flight data for ATC = " + str(self.id))



# Drone object works together with the map
# the drone decide for itself where it would like to go next


class Drone(metaclass=abc.ABCMeta):
    """super class, support different types of drones

    Attributes:
        response_data: data generated by this drone and other drones
    """

    @abc.abstractmethod
    def next_step(self):
        """abstract class, determine and change the next location for the drone
        based on the previous move or algorithm


        Extended description of function.

        Args:
            arg1 (int): Description of arg1
            arg2 (str): Description of arg2

        Returns:
            bool: Description of return value

        """
        # abstract method to execute everytime the drone advances in the execution loop
        pass

    @abc.abstractmethod
    def emit_response_data(self):

        # output the response data from the drone
        # abstact method to execute everytime an execution cycle just finished
        pass

    def receive_shared_flight_data(self, shared_flight_data):
        self.shared_flight_data = shared_flight_data
    
    # deprecated
    def receive_response_data(self, response_data):
        # receive response data from the broadcaster in the execution loop
        self.response_data = response_data

    # deprecated
    def has_response_data(self):
        # check whether response data is initialized
        return hasattr(self, "response_data")

    def has_shared_flight_data(self):
        # check whether response data is initialized
        return hasattr(self, "shared_flight_data")

    # deprecated
    def get_response_data(self):
        # fetch the response data received from the broadcaster in the run method in the MissionPlanner
        if hasattr(self, "response_data"):
            return self.response_data
        else:
            raise RuntimeError(
                "response_data variable has not been initialized.")

    def get_shared_flight_data(self):
        # fetch the response data received from the broadcaster in the run method in the MissionPlanner
        if hasattr(self, "shared_flight_data"):
            return self.shared_flight_data
        else:
            raise RuntimeError(
                "shared_flight_data variable has not been initialized.")

    def init_attribute(self):
        # initialize the attribute
        # can hold various things like flight path list of tuple of coordinates,
        self.attributes = dict()

    def set_identifier(self, identifier):
        # set identifier for the drone
        self.identifier = identifier

    def get_identifier(self):
        # get the identifier for the drone
        if hasattr(self, "identifier"):
            return self.identifier
        else:
            raise RuntimeError(
                "drone identifier variable has not been initialized.")

    # duplicate for self.get_identifier
    def get_id(self):
        # get the identifier for the drone
        if hasattr(self, "identifier"):
            return self.identifier
        else:
            raise RuntimeError(
                "drone identifier variable has not been initialized.")

    def set_internal_map(self, internal_map):
        # set the internal map associated with the drone
        self.internal_map = internal_map

    def get_internal_map(self):
        if hasattr(self, "internal_map"):
            return self.internal_map
        else:
            raise RuntimeError("map variable has not been initialized.")

    # def set_initial_location(self, init_x_cor, init_y_cor):
    def set_init_coord(self, coord):
        """Summary line.

        Extended description of function.

        Args:
            arg1 (int): Description of arg1
            arg2 (str): Description of arg2

        Returns:
            bool: Description of return value

        """
        # set the initial position coordinates for the drone
        self.init_coord = coord
        self.current_coord = coord

        # self.init_x_cor = init_x_cor
        # self.init_y_cor = init_y_cor

        # when setting the initial value, the current location will be automatically set to the intial values
        # self.set_current_location(init_x_cor, init_y_cor)

    # def get_init_x_cor(self):
    #     # get the initial X coordinate
    #     return self.init_x_cor

    # def get_init_y_cor(self):
    #     # get the initial Y coordinate
    #     return self.init_y_cor

    def get_init_coord(self):
        return self.init_coord

    def set_current_coord(self, coord):
        # set the current location for the drone
        self.current_coord = coord

    def get_current_coord(self):
        # obtain the current drone location
        # return (self.x_cor, self.y_cor)
        return self.current_coord

    def get_current_location_map_cell(self):
        # get the map_cell object of the current location
        # first ensure that the map variable is set
        if hasattr(self, "internal_map"):
            return self.internal_map.get_map_cell(self.get_current_coord())
        else:
            raise RuntimeError("map variable has not been initialized.")

    # def get_x_cor(self):
    #     return self.x_cor

    # def get_y_cor(self):
    #     return self.y_cor

    def __str__(self):
        return self.get_identifier() + " Drone: " + str(self.get_current_coord())

    def __repr__(self):
        return self.get_identifier() + " Drone: (" + str(self.get_current_coord())

# EnemyDrone class inherits the Drone parent class


class EnemyDrone(Drone):
    def __init__(self, internal_map):
        self.set_internal_map(internal_map)
        self.set_identifier("Enemy")

    def next_step(self):
        # the next_step of the enemy drone depends on the location of the ego drone
        # it will select the path that will maximally approach the ego drone

        # Note that the response data may not be intialized the first time the cycle executes.
        # the next move of the enemy drone will depend on the previous location of the ego drone
        # if self.has_response_data():
        if self.has_shared_flight_data():

            # case when the response data has been received
            # response_data = self.get_response_data()
            shared_flight_data = self.get_shared_flight_data()

            # get the Map_Cell on the current location
            current_map_cell = self.internal_map.get_map_cell(
                self.get_current_coord())

            # set the output to 1 (debug, show path)
            current_map_cell.set_output(1)

            # find all neighboring map_cell (neighbor_list {"north": map_cell "south", "east", "west", ...})
            neighbor_dict = self.internal_map.find_neighbors_8(
                current_map_cell)

            neighbor_map_cells = neighbor_dict.values()

            # warning: this is highly brittle
            # acquire the ego drone x, y coordinates from the response data
            # ego_drone_x_cor = response_data["Ego"]["current_x_cor"]
            # ego_drone_y_cor = response_data["Ego"]["current_y_cor"]

            # ego_drone_coord = response_data["Ego"]["current_map_cell"].get_coord(
            # )
            ego_drone_coord = shared_flight_data.get("Ego").get_map_cell().get_coord()
            ego_drone_map_cell = self.get_internal_map().get_map_cell(ego_drone_coord)

            # initialize the min distance to the diagonal length of the map
            # which is the maximum distance you can achieve on the map
            min_ego_enemy_drone_distance = self.get_internal_map().get_diagonal_length()

            # initialize the next map cell by default to current map cell
            next_step_map_cell = current_map_cell

            for neighbor_map_cell in neighbor_map_cells:
                distance_to_ego_drone = neighbor_map_cell.distance_to(
                    ego_drone_map_cell)
                if min_ego_enemy_drone_distance > distance_to_ego_drone:
                    min_ego_enemy_drone_distance = distance_to_ego_drone
                    next_step_map_cell = neighbor_map_cell

            self.set_current_coord(next_step_map_cell.get_coord())
            # decision: distance advances (dynamic) vs. distance only (static comparison)
            # find all neighbors
            # check which path can advance the most (maybe restrict to 4 neighbors instead of 8 in the future?)

        else:
            # case when the response data is not initialized
            # drone location remain unchanged
            pass

    def emit_response_data(self):
        # return {"current_x_cor": self.get_x_cor(), "current_y_cor": self.get_y_cor(), "current_map_cell": self.get_current_location_map_cell()}
        return {"current_map_cell": self.get_current_location_map_cell()}

    def emit_flight_data(self):
        return Drone_Flight_Data(self.get_id(), {"map_cell": self.get_current_location_map_cell()})

# EgoDrone class inherits the Drone parent class


class EgoDrone(Drone):
    # initialize the ego drone with internal map
    def __init__(self, internal_map):
        self.set_internal_map(internal_map)
        self.set_identifier("Ego")

        # set the mission of the EgoDrone
        # self.fly_x_squared

    def next_step(self):
        # print("hello")

        # get the Map_Cell on the current location
        # Coord(self.get_x_cor(), self.get_y_cor()))
        current_map_cell = self.internal_map.get_map_cell(
            self.get_current_coord())

        # print(current_map_cell)
        # mark current map cell
        current_map_cell.set_output(1)

        # mark the visited attribute in the map cell as true
        current_map_cell.set_attribute("visited", True)

        # compute the dynamic robustness for all cells based on the location of the drone
        # self.compute_dynamic_robustness(current_map_cell)

        # find all neighboring map_cell (neighbor_list {"north": "south", "east", "west", ...})
        neighbor_dict = self.internal_map.find_neighbors_8(current_map_cell)

        # find the next cell, using the initial coordinates, since graph has to be based on the intial x and y coordinates
        current_map_cell = self.find_next_map_cell_fly_x_squared(
            neighbor_dict, self.get_init_coord())

        # set the current location to the new location
        self.set_current_coord(current_map_cell.get_coord())

    def emit_response_data(self):
        # return {"current_x_cor": self.get_x_cor(), "current_y_cor": self.get_y_cor(), "current_map_cell": self.get_current_location_map_cell()}
        return {"current_map_cell": self.get_current_location_map_cell()}

    def emit_flight_data(self):
        return Drone_Flight_Data(self.get_id(), {"map_cell": self.get_current_location_map_cell()})

    # def create_drone("ego/enemy", tuple of initial position on the map, map_object)
    # check if the initial position is valid on the map
    # debugging
    # return a map cell
    # init_x_cor, init_y_cor):
    def find_next_map_cell_fly_x_squared(self, neighbor_dict, coord):
        # graph_length : map_length
        # the ratio between the graph (mathematical formula) to the discretized map (cell length counts as 1)
        graph_to_map_ratio = 2/self.internal_map.get_width()

        # encode the precedence rule to resolve the direction to fly to when the score is the same
        precedence = ["east", "southeast", "south", "southwest",
                      "west", "northwest", "north", "northeast"]

        formula = "x**2"
        formula_parsed = parser.expr(formula).compile()

        # check whether the cell is visited already, if so, don't visit,
        # if not, check close proximity to the graph using the formula
        # debug "flyeight-visited"
        min_diff = 1

        # {"map_cell": diff value...}
        map_cell_displacement_diff = {}

        # compute the lowest diff in the neighbor_dict
        for key in neighbor_dict.keys():
            # get the current neighbor map cell
            current_map_cell = neighbor_dict[key]

            # print("checking" + str(current_map_cell))

            # ensure that the cell is not yet visited
            # if current_map_cell.has_attribute("visited") and current_map_cell.get_attribute("visited"):
            # print(current_map_cell.get_attribute_dict())

            # debug, flip the guard below to make it work
            if current_map_cell.has_attribute("visited") and current_map_cell.get_attribute("visited"):
                # if current_map_cell.get_output() == 1:
                # print("Cell " + str(current_map_cell) + " is visited")
                pass

            else:
                # compute the x coordinate displacement from the origin
                x_cor_displacement = current_map_cell.x() - coord.x()

                # compute the x displacement on the graph from the origin
                x_graph_displacement = x_cor_displacement * graph_to_map_ratio

                # assign x value in formula
                x = x_graph_displacement

                # evaluate the formula
                y_graph_displacement = eval(formula_parsed)
                # print(y_graph_displacement)

                # compute the y coordinate displacement from the origin
                y_cor_displacement = y_graph_displacement / graph_to_map_ratio

                # compute the actual y coordinate displace from the current map cell
                actual_y_cor_displacement = current_map_cell.y() - coord.y()

                # compute the difference in displacement
                current_diff = abs(y_cor_displacement +
                                   actual_y_cor_displacement)

                map_cell_displacement_diff[current_map_cell] = (
                    key, current_diff)

        # map_cell_displacement_diff
        #{"map_cell": ("north", displacement_diff)}

        # sorting the displacement_diff dictionary by its values (ascending order)
        sorted_displacement_diff = sorted(
            map_cell_displacement_diff.items(), key=lambda x: x[1][1])

        #[(map_cell, ("north", displacement_diff)), (...)]
        # find the cell with minimum different value (deviation) from the mathematical calculation
        min_diff_value = sorted_displacement_diff[0][1][1]
        # sorted_displacement_diff is sorted by displacement_diff

        same_displacement_diff_value_dict = {}

        for i in sorted_displacement_diff:
            if i[1][1] == min_diff_value:
                same_displacement_diff_value_dict[i[1][0]] = i[0]

        # same_displacement_diff_value_dict
        # {"north": map_cell}

        # work on precedence
        for direction in precedence:
            if direction in same_displacement_diff_value_dict.keys():
                # print("Selected " + direction)
                return same_displacement_diff_value_dict[direction]
        # print(sorted_displacement_diff)

        # return sorted_displacement_diff[0][0]
